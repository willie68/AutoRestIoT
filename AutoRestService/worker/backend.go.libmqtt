package worker

import (
	"time"

	"encoding/json"

	"github.com/goiiot/libmqtt"
	"github.com/willie68/AutoRestIoT/dao"
	"github.com/willie68/AutoRestIoT/model"
)

//ValidateBackend validate if a backend definition is valid
func ValidateBackend(be model.Backend) error {
	// checking backendname format
	// checking models
	// checking indexes
	return nil
}

func RegisterBackend(backend model.Backend) error {
	// create indexes if missing
	models := backend.Models
	for _, bemodel := range models {
		err := createIndex(bemodel, backend.Backendname)
		if err != nil {
			log.Fatalf("%v", err)
		}
	}
	// creating source plugins
	for _, datasource := range backend.DataSources {
		err := createDatasource(datasource, backend.Backendname)
		if err != nil {
			log.Fatalf("%v", err)
		}
	}
	return nil
}

func createDatasource(datasource model.DataSource, backendname string) error {
	switch datasource.Type {
	case "mqtt":
		err := registerMQTTTopic(datasource.Name, backendname, datasource.Destination, datasource.Config.(model.DataSourceConfigMQTT))
		if err != nil {
			return err
		}
	default:
		log.Alertf("type \"%s\" is not availble as data source type", datasource.Type)
	}
	return nil
}

type MqttDatasource struct {
	Client  libmqtt.Client
	Broker  string
	Backend string
	Model   string
	Topic   string
	Payload string
}

var mqttClients = make([]MqttDatasource, 0)

func storeMessage(datasource MqttDatasource, topic string, msg []byte) {
	//log.Infof("MODEL: %s.%s TOPIC: %s  MSG: %s", datasource.Backend, datasource.Model, msg.Topic(), msg.Payload())
	route := model.Route{
		Backend: datasource.Backend,
		Model:   datasource.Model,
	}
	if datasource.Payload == "application/json" {
		var data model.JsonMap
		err := json.Unmarshal(msg, &data)
		if err != nil {
			log.Alertf("%v", err)
		} else {
			Store(route, data)
		}
	}
}

func registerMQTTTopic(clientID string, backendname string, destinationmodel string, config model.DataSourceConfigMQTT) error {
	//	mqtt.DEBUG = orglog.New(os.Stdout, "DEBUG", 0)
	client, err := libmqtt.NewClient(
		// try MQTT 5.0 and fallback to MQTT 3.1.1
		libmqtt.WithVersion(libmqtt.V5, true),
		// enable keepalive (10s interval) with 20% tolerance
		libmqtt.WithKeepalive(10, 1.2),
		// enable auto reconnect and set backoff strategy
		libmqtt.WithAutoReconnect(true),
		libmqtt.WithBackoffStrategy(time.Second, 5*time.Second, 1.2),
		libmqtt.WithIdentity(config.Username, config.Password),
		libmqtt.WithConnHandleFunc(func(client libmqtt.Client, server string, code byte, err error) {
			if err != nil {
				log.Alertf("connect to server [%v] failed: %v", server, err)
				return
			}

			if code != libmqtt.CodeSuccess {
				log.Alertf("connect to server [%v] failed with server code [%v]", server, code)
				return
			}

			go subscribe(config.Topic, client)
		}),
		libmqtt.WithNetHandleFunc(netHandler),
		libmqtt.WithSubHandleFunc(subHandler),
		libmqtt.WithUnsubHandleFunc(unSubHandler),
		libmqtt.WithPubHandleFunc(pubHandler),
		libmqtt.WithPersistHandleFunc(persistHandler),
	)

	if err != nil {
		return err
	}

	datasource := MqttDatasource{
		Client:  client,
		Broker:  config.Broker,
		Backend: backendname,
		Model:   destinationmodel,
		Topic:   config.Topic,
		Payload: config.Payload,
	}

	// handle every subscribed message (just for example)
	client.HandleTopic(config.Topic, func(client libmqtt.Client, topic string, qos libmqtt.QosLevel, msg []byte) {
		//log.Infof("[%v] message: %v", topic, string(msg))
		storeMessage(datasource, topic, msg)
	})

	err = client.ConnectServer(config.Broker)

	mqttClients = append(mqttClients, datasource)

	log.Infof("registering topic %s on %s for model %s", config.Topic, config.Broker, destinationmodel)
	return nil
}

func subscribe(topic string, client libmqtt.Client) {
	go func() {
		// subscribe to some topics
		client.Subscribe(&libmqtt.Topic{
			Name: topic,
			Qos:  libmqtt.Qos1,
		})
	}()
}

func createIndex(bemodel model.Model, backendname string) error {
	indexes := bemodel.Indexes
	// define stardard fulltext index
	_, ok := bemodel.GetIndex(dao.FulltextIndexName)
	if !ok {
		fulltextIndex := model.Index{
			Name:   dao.FulltextIndexName,
			Fields: bemodel.GetFieldNames(),
		}
		indexes = append(indexes, fulltextIndex)
	}
	// define stardard indexes
	for _, field := range bemodel.Fields {
		_, ok := bemodel.GetIndex(dao.FulltextIndexName)
		if !ok {
			index := model.Index{
				Name:   field.Name,
				Fields: []string{field.Name},
			}
			indexes = append(indexes, index)
		}
	}
	// Delete unused indexes
	route := model.Route{
		Backend: backendname,
		Model:   bemodel.Name,
	}
	names, err := dao.GetStorage().GetIndexNames(route)
	if err != nil {
		return err
	}
	for _, idxName := range names {
		found := false
		for _, index := range indexes {
			if idxName == index.Name {
				found = true
				break
			}
		}
		if !found {
			err = dao.GetStorage().DeleteIndex(route, idxName)
		}
	}
	for _, index := range indexes {
		err := dao.GetStorage().UpdateIndex(route, index)
		if err != nil {
			return err
		}
	}
	return nil
}

func netHandler(client libmqtt.Client, server string, err error) {
	if err != nil {
		log.Alertf("error happened to connection to server [%v]: %v", server, err)
	}
}

func persistHandler(client libmqtt.Client, packet libmqtt.Packet, err error) {
	if err != nil {
		log.Alertf("session persist error: %v", err)
	}
}

func subHandler(client libmqtt.Client, topics []*libmqtt.Topic, err error) {
	if err != nil {
		for _, t := range topics {
			log.Alertf("subscribe to topic [%v] failed: %v", t.Name, err)
		}
	} else {
		for _, t := range topics {
			log.Infof("subscribe to topic [%v] success: %v", t.Name, err)
		}
	}
}

func unSubHandler(client libmqtt.Client, topic []string, err error) {
	if err != nil {
		// handle unsubscribe failure
		for _, t := range topic {
			log.Alertf("unsubscribe to topic [%v] failed: %v", t, err)
		}
	} else {
		for _, t := range topic {
			log.Alertf("unsubscribe to topic [%v] failed: %v", t, err)
		}
	}
}

func pubHandler(client libmqtt.Client, topic string, err error) {
	if err != nil {
		log.Alertf("publish packet to topic [%v] failed: %v", topic, err)
	} else {
		log.Infof("publish packet to topic [%v] success: %v", topic, err)
	}
}